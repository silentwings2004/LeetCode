package LC2700_3000;
import java.util.*;
public class LC2875_MinimumSizeSubarrayinInfiniteArray {
    /**
     * You are given a 0-indexed array nums and an integer target.
     *
     * A 0-indexed array infinite_nums is generated by infinitely appending the elements of nums to itself.
     *
     * Return the length of the shortest subarray of the array infinite_nums with a sum equal to target. If there is no
     * such subarray return -1.
     *
     * Input: nums = [1,2,3], target = 5
     * Output: 2
     *
     * Input: nums = [1,1,1,2,3], target = 4
     * Output: 2
     *
     * Input: nums = [2,4,6,8], target = 3
     * Output: -1
     *
     * Constraints:
     *
     * 1 <= nums.length <= 10^5
     * 1 <= nums[i] <= 10^5
     * 1 <= target <= 10^9
     * @param nums
     * @param target
     * @return
     */
    // S1
    // time = O(n), space = O(n)
    public int minSizeSubarray(int[] nums, int target) {
        int n = nums.length, INF = (int)1e6;
        long sum = 0;
        for (int x : nums) sum += x;
        long res = target / sum * n, r = target % sum;
        if (r == 0) return (int)res;

        long s = 0;
        HashMap<Long, Integer> map = new HashMap<>();
        map.put(0L, -1);
        int t = INF;
        for (int i = 0; i < n * 2; i++) {
            s += nums[i % n];
            if (map.containsKey(s - r)) t = Math.min(t, i - map.get(s - r));
            map.put(s, i);
        }
        if (t == INF) res = 0;
        else res += t;
        return res == 0 ? -1 : (int)res;
    }

    // S1.2
    // time = O(n), space = O(1)
    public int minSizeSubarray2(int[] nums, int target) {
        int tot = 0, INF = (int)2e9;
        for (int x : nums) tot += x;
        int res = INF, j = 0, n = nums.length;
        for (int i = 0, s = 0; i < n * 2; i++) {
            s += nums[i % n];
            while (s > target % tot) {
                s -= nums[j % n];
                j++;
            }
            if (s == target % tot) res = Math.min(res, i - j + 1);
        }
        if (res == INF) return -1;
        return res + target / tot * n;
    }
}